{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Scaffold Next.js project with TypeScript and App Router",
        "description": "Scaffold new Next.js project with TypeScript, strict mode, and App Router. Set up project structure with domain-based folders. Install required dependencies: React Query, Zustand, chart library (Recharts), code editor (Monaco), date handling, form validation (React Hook Form + Zod). Configure Tailwind CSS for styling.",
        "details": "Run `npx create-next-app@latest frontend --typescript --tailwind --eslint --app --src-dir` or similar. Set up environment files (.env.local.example with NEXT_PUBLIC_API_BASE_URL). Create folder structure: src/app (App Router pages), src/components (UI components), src/hooks (custom hooks), src/lib (utilities, api client), src/types (TypeScript types), src/stores (Zustand stores). Key dependencies: @tanstack/react-query, zustand, recharts, @monaco-editor/react, react-hook-form + @hookform/resolvers + zod, date-fns, axios. Configure next.config.js for standalone output mode.",
        "testStrategy": "Verify project builds successfully with `npm run build`. Check TypeScript strict mode passes without errors. Verify all routes are accessible.",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Next.js project with create-next-app",
            "description": "Run npx create-next-app@latest to scaffold a new Next.js project with TypeScript, Tailwind CSS, ESLint, and App Router in the 'frontend' directory. Configure initial setup including removing demo pages and creating .env.local.example.",
            "dependencies": [],
            "details": "Execute: npx create-next-app@latest frontend --typescript --tailwind --eslint --app --src-dir --no-import-alias. Verify the project structure includes src/app, src/components, src/hooks, src/lib, src/types, src/stores folders. Check that next.config.js has strict mode enabled. Create .env.local.example with NEXT_PUBLIC_API_BASE_URL variable. Remove any default Next.js demo pages and styles.",
            "status": "completed",
            "testStrategy": "Run 'npm run build' to verify project compiles without TypeScript errors. Verify strict mode is enabled by checking tsconfig.json. Test that 'npm run dev' starts successfully.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install dependencies and create API client with TypeScript types",
            "description": "Install all required frontend dependencies including React Query, Zustand, Recharts, Monaco Editor, React Hook Form with Zod, date-fns, and axios. Create API client and TypeScript type definitions mirroring backend Pydantic models.",
            "dependencies": [
              1
            ],
            "details": "Run: npm install @tanstack/react-query zustand recharts @monaco-editor/react react-hook-form @hookform/resolvers zod date-fns axios. Create src/lib/api/client.ts with axios instance configured with base URL from NEXT_PUBLIC_API_BASE_URL env var, interceptors for request/response, and error handling. Create src/types/api.ts with TypeScript interfaces mirroring backend Pydantic models: BacktestRequest, BacktestParams, ContributionFrequency (enum), ContributionPlan, FeeSettings, LLMSettings, GeneratedCode, ModelInfo, JobStatus (enum), ExecuteBacktestRequest/Response, BacktestResultResponse, EquityChartResponse, DrawdownChartResponse, MonthlyReturnsResponse.",
            "status": "completed",
            "testStrategy": "Verify all packages install without errors. Run TypeScript compilation to ensure types are correct. Test API client initialization with mock base URL.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configure Next.js for production deployment",
            "description": "Configure Next.js for production deployment with standalone output mode, TypeScript path aliases, and environment variable validation for Docker compatibility.",
            "dependencies": [
              1
            ],
            "details": "Edit next.config.js to add output: 'standalone' and experimental features. Create or update tsconfig.json paths for @/lib, @/components, @/hooks, @/types, @/stores aliases pointing to src directory. Configure next.config.js with proper headers for API calls, image optimization settings, and react strict mode. Set up proper environment variable schema validation using zod for required env vars.",
            "status": "completed",
            "testStrategy": "Run 'npm run build' to verify standalone output is generated correctly. Check that the output/.next/standalone directory contains the necessary files. Verify path aliases work in imports.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create folder structure for domain-based architecture",
            "description": "Create folder structure following domain-based architecture with proper barrel exports for clean imports across the application.",
            "dependencies": [
              1
            ],
            "details": "Create directory structure: src/app, src/components/ui, src/components/backtest, src/hooks, src/lib/api, src/lib/utils, src/types, src/stores. Add index.ts barrel files for each directory. Create src/app/page.tsx as main landing page. Set up src/app/layout.tsx with proper metadata and basic structure. Create sample components to verify folder structure works correctly.",
            "status": "completed",
            "testStrategy": "Verify all directories exist and contain index files. Test that imports using @/ alias work correctly. Run TypeScript compilation to verify no path resolution errors.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure npm scripts and environment files",
            "description": "Set up development and production scripts in package.json, verify .gitignore patterns, and create local environment configuration files.",
            "dependencies": [
              1
            ],
            "details": "Update package.json with scripts: 'dev' (next dev), 'build' (next build), 'start' (next start), 'lint' (next lint), 'type-check' (tsc --noEmit). Verify .gitignore has proper patterns for Next.js projects. Create .env.local with NEXT_PUBLIC_API_BASE_URL=http://localhost:8000/api/v1 for local development. Test that all npm scripts run without errors.",
            "status": "completed",
            "testStrategy": "Run each npm script to verify they work: npm run dev, npm run build, npm run lint. Verify .gitignore patterns are correct by checking git status. Confirm environment files are properly excluded.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 2,
        "title": "Build typed API client layer and DTOs",
        "description": "Create typed API client layer that mirrors backend Pydantic models. Generate TypeScript interfaces for all API request/response types aligned with backend models. Implement API client with axios wrapper with proper error handling.",
        "details": "Create src/types/api.ts with interfaces matching backend models: BacktestRequest, BacktestParams, ContributionFrequency (enum), ContributionPlan, FeeSettings, LLMSettings, GeneratedCode, ModelInfo, JobStatus (enum), ExecuteBacktestRequest/Response, BacktestResultResponse, EquityChartResponse, DrawdownChartResponse, MonthlyReturnsResponse. Create src/lib/api/client.ts with base URL from env var, axios instance with interceptors, and functions: generateCode(), executeBacktest(), getJobStatus(), getJobResult(), getFormattedResult().",
        "testStrategy": "Write unit tests for API client request/response mapping. Test error handling for 400/404/500 responses. Mock API responses for validation.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "completed",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up test environment with vitest",
            "description": "Set up test environment with vitest, @testing-library/react, jest-environment-jsdom, and msw. Configure vitest.config.ts with jsdom environment, path aliases, and test scripts in package.json.",
            "dependencies": [],
            "details": "Run npm install --save-dev vitest @testing-library/react @testing-library/jest-dom jest-environment-jsdom msw @types/msw. Create frontend/vitest.config.ts with test environment: 'jsdom', aliases for @/* paths, globals: true. Add test scripts to package.json: test, test:run, test:coverage. Create tests/setup.ts for test environment.",
            "status": "completed",
            "testStrategy": "Run npm run test to verify vitest works. Check test discovery works.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Align frontend DTOs with backend Pydantic models",
            "description": "Review and align frontend TypeScript interfaces with backend Pydantic models. Fix field name mismatches and add missing fields to ensure consistency.",
            "dependencies": [],
            "details": "Update src/types/api.ts: 1) Rename ModelInfo.model_name to model_id. 2) Rename GeneratedCode.detected_tickers to tickers. 3) Add missing LLMSettings fields: provider, model, seed. 4) Add CANCELLED and TIMEOUT to JobStatus enum. 5) Ensure all types are exported from src/types/index.ts. Run type-check.",
            "status": "completed",
            "testStrategy": "Run npm run type-check to verify TypeScript compiles.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create unit tests for API types",
            "description": "Create unit tests for API types in tests/unit/api-types.test.ts. Test enum values, interface shapes, and type structures for all DTOs.",
            "dependencies": [
              1
            ],
            "details": "Create tests/unit/api-types.test.ts: 1) Test ContributionFrequency enum values. 2) Test JobStatus enum values. 3) Test BacktestRequest has strategy and params. 4) Test BacktestParams structure. 5) Test GeneratedCode shape. 6) Test BacktestResultResponse fields.",
            "status": "completed",
            "testStrategy": "Run npm run test to execute tests.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create unit tests for API client with msw",
            "description": "Create unit tests for API client functions in tests/unit/api-client.test.ts using msw to mock HTTP requests and responses.",
            "dependencies": [
              1
            ],
            "details": "Create tests/unit/api-client.test.ts: 1) Set up msw http server. 2) Create handlers for all API endpoints. 3) Test generateCode(), executeBacktest(), getJobStatus(), getJobResult(), getFormattedResult() with mock responses.",
            "status": "completed",
            "testStrategy": "Run npm run test to execute API client tests.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create error handling tests for HTTP status codes",
            "description": "Create error handling tests for HTTP status codes 400, 401, 403, 404, 500 and network errors in tests/unit/api-errors.test.ts.",
            "dependencies": [
              1,
              4
            ],
            "details": "Create tests/unit/api-errors.test.ts: 1) Test 400 Bad Request error handling. 2) Test 401/403 authentication errors. 3) Test 404 Not Found error. 4) Test 500 Internal Server Error. 5) Test network error handling. 6) Test timeout error. Use msw to mock error responses.",
            "status": "completed",
            "testStrategy": "Run npm run test to execute error handling tests.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement base layout and shared UI components",
        "description": "Implement base layout with responsive two-pane design, navigation, and shared UI components. Set up React Query provider and Zustand store for global state management.",
        "details": "Create src/app/layout.tsx with React Query Provider wrapper, global styles and Tailwind imports. Create src/components/ui/ with Button, Input, Textarea, Select, Card, Alert, LoadingSpinner components. Create src/stores/useBacktestStore.ts with Zustand for generatedCode, jobId, jobStatus, results, uiToggles. Create main page with two-pane layout: Left (config form + actions), Right (code editor + results).",
        "testStrategy": "Verify layout renders correctly on desktop and mobile breakpoints. Test React Query cache invalidation. Test Zustand store state updates.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "completed",
        "subtasks": [
          {
            "id": 1,
            "title": "Create missing UI components",
            "description": "Create missing UI components in src/components/ui/ directory: Input.tsx (with label, error, disabled props), Textarea.tsx (with rows, placeholder, disabled), Select.tsx (with options array, label, error), Alert.tsx (with variant for info/success/error/warning), LoadingSpinner.tsx (with size prop, centered option). All components should follow existing design patterns from Button.tsx and Card.tsx using Tailwind CSS.",
            "dependencies": [],
            "details": "Create Input.tsx with label, error message, and disabled state support using Tailwind for styling. Create Textarea.tsx with configurable rows and full-width. Create Select.tsx with options array containing value/label pairs. Create Alert.tsx with variant types (info, success, error, warning) and icon support. Create LoadingSpinner.tsx with size variants (sm, md, lg) and optional centering wrapper.",
            "status": "completed",
            "testStrategy": "Test each component renders correctly with different props. Verify Input shows error state, Textarea resizes, Select shows options, Alert displays correct colors per variant, Spinner shows different sizes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enhance Zustand store with uiToggles",
            "description": "Enhance useBacktestStore.ts with uiToggles state for managing UI panel visibility and expanded states. Add toggle functions for code editor visibility, results panel, config panel collapse state, and other UI state that needs persistence across components.",
            "dependencies": [
              1
            ],
            "details": "Add uiToggles interface with isCodeEditorOpen, isResultsOpen, isConfigExpanded, selectedTab (code/results). Add setUiToggle functions to update individual toggles. Update reset function to also clear uiToggles. Ensure store follows Zustand best practices with proper typing.",
            "status": "completed",
            "testStrategy": "Verify uiToggles state updates correctly. Test reset clears all UI state. Verify type safety for all toggle functions.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Navigation/Header component",
            "description": "Create Navigation/Header component in src/components/layout/Header.tsx with app branding, navigation links, and responsive mobile menu. Include logo, app name 'Backtest Simulation', and optional user actions area.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create Header.tsx with Space Grotesk font logo, app title, and responsive design. Include hamburger menu for mobile. Add basic navigation structure. Export from src/components/layout/index.ts. Use existing CSS variables for theming.",
            "status": "completed",
            "testStrategy": "Verify Header renders with logo and title. Test responsive mobile menu toggle. Verify it integrates with layout.tsx properly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Improve two-pane responsive layout",
            "description": "Enhance BacktestWorkspace.tsx with proper two-pane responsive layout: Left pane for Configuration Form + Actions (config panel), Right pane for Code Editor + Results. Use grid layout with responsive breakpoints (stack on mobile, side-by-side on md+).",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Refactor BacktestWorkspace to use CSS Grid with md:grid-cols-2 for responsive two-pane. Create left pane with Card containing config form placeholder and action buttons. Create right pane with tabbed interface for code editor and results. Add proper spacing and gap utilities. Use uiToggles from store to control pane visibility.",
            "status": "completed",
            "testStrategy": "Verify layout renders side-by-side on desktop (md breakpoint). Verify stacks vertically on mobile. Test tab switching in right pane. Verify action buttons render in left pane.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Export all UI components and verify integration",
            "description": "Update src/components/ui/index.ts to export all UI components including newly created Input, Textarea, Select, Alert, LoadingSpinner. Verify all exports work correctly and components can be imported from @/components/ui.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add export statements for Input, Textarea, Select, Alert, LoadingSpinner in index.ts. Verify all imports work in other components. Test that components can be imported individually or as named exports from @/components/ui.",
            "status": "completed",
            "testStrategy": "Verify all UI components can be imported from @/components/ui. Test no import errors in BacktestWorkspace. Verify no circular dependency issues.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement config form with validation",
        "description": "Build strategy and parameter input form with all fields specified in FR-2: strategy text, date range, initial capital, benchmarks, contribution settings, fees, dividend reinvestment toggle, web search toggle. Add client-side validation.",
        "details": "Create src/components/backtest/ConfigForm.tsx using React Hook Form + Zod. Schema: strategy (10-10000 chars), start_date (>=2001-01-01), end_date (<=today), initial_capital (>=1000), benchmarks (min 1), contribution.frequency/amount, fees (0-10%), dividend_reinvestment, llm_settings.web_search_enabled. Components: StrategyInput, DateRangePicker, CapitalInput, BenchmarkSelect, ContributionSettings, FeeSettings, Toggles, ValidationSummary.",
        "testStrategy": "Test form validation for all fields. Test character counter. Verify date range validation. Test submission with valid/invalid data.",
        "priority": "high",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create form UI primitive components",
            "description": "Create reusable form UI primitives in src/components/ui/: Input.tsx (with label, error, helper text), Textarea.tsx (with character counter), Select.tsx (with options prop), and Toggle.tsx (switch component). Export all from ui/index.ts.",
            "dependencies": [
              3
            ],
            "details": "Input component needs type prop, label, placeholder, error message, helper text. Textarea needs rows, maxLength, showCount option. Select needs options array with label/value, placeholder. Toggle needs label and description. All should follow existing Button/Card styling patterns using Tailwind.",
            "status": "pending",
            "testStrategy": "Test Input renders with label and displays error. Test Textarea character counter. Test Select options rendering. Test Toggle switch state changes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-14T16:22:03.529Z"
          },
          {
            "id": 2,
            "title": "Create Zod validation schema",
            "description": "Create Zod validation schema in src/lib/validations/backtest.ts defining all form field validations matching FR-2 requirements: strategy (10-10000 chars), start_date (>=2001-01-01), end_date (<=today), initial_capital (>=1000), benchmarks (min 1), contribution.frequency/amount, fees (0-10%), dividend_reinvestment, llm_settings.web_search_enabled.",
            "dependencies": [
              3
            ],
            "details": "Use zod for schema definition. Create separate schemas for nested objects (contribution, fees, llm_settings). Use z.coerce.date() for date fields. Include custom error messages. Export type inferred from schema.",
            "status": "pending",
            "testStrategy": "Test valid data passes. Test strategy min/max length validation. Test date range validation (start >= 2001, end <= today). Test capital >= 1000. Test benchmarks min 1. Test fees 0-10%.",
            "parentId": "undefined",
            "updatedAt": "2026-02-14T16:22:05.048Z"
          },
          {
            "id": 3,
            "title": "Create StrategyInput and DateRangePicker components",
            "description": "Create StrategyInput and DateRangePicker components in src/components/backtest/: StrategyInput.tsx using Textarea with character counter, DateRangePicker.tsx with two date inputs and cross-field validation.",
            "dependencies": [
              3
            ],
            "details": "StrategyInput: Use Textarea, show character count (X/10000), limit to 10000 chars. DateRangePicker: Two date inputs (start, end), validate start >= 2001-01-01, end <= today, start <= end. Use native date inputs or simple custom implementation.",
            "status": "pending",
            "testStrategy": "Test StrategyInput character counter updates. Test StrategyInput shows error for <10 or >10000 chars. Test DateRangePicker start/end validation. Test cross-field validation (start <= end).",
            "parentId": "undefined",
            "updatedAt": "2026-02-14T16:22:06.564Z"
          },
          {
            "id": 4,
            "title": "Create CapitalInput, BenchmarkSelect, ContributionSettings components",
            "description": "Create CapitalInput, BenchmarkSelect, and ContributionSettings components in src/components/backtest/. CapitalInput: number input with currency formatting. BenchmarkSelect: multi-select for benchmarks (KOSPI, KOSDAQ, etc). ContributionSettings: frequency dropdown + amount input.",
            "dependencies": [
              3
            ],
            "details": "CapitalInput: Input with type=number, min=1000, show formatted value. BenchmarkSelect: Multi-select with checkboxes or tags, min 1 required, show selected count. ContributionSettings: Select for frequency (monthly, quarterly, semiannual, annual), Input for amount (>=0).",
            "status": "pending",
            "testStrategy": "Test CapitalInput validates >= 1000. Test BenchmarkSelect requires min 1 selection. Test ContributionSettings frequency/amount validation.",
            "parentId": "undefined",
            "updatedAt": "2026-02-14T16:22:08.072Z"
          },
          {
            "id": 5,
            "title": "Create Toggles, ValidationSummary and integrate ConfigForm",
            "description": "Create Toggles component (dividend_reinvestment, web_search), ValidationSummary component, and integrate all fields into ConfigForm.tsx using React Hook Form + zod-resolver.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Toggles: Two toggle switches for dividend_reinvestment and llm_settings.web_search_enabled. ValidationSummary: List of all validation errors at top of form. ConfigForm: Use useForm hook, integrate all components, handle submit, show loading state. Wire up form to store actions.",
            "status": "pending",
            "testStrategy": "Test form validation on submit. Test ValidationSummary shows all errors. Test toggles persist state. Test form submits valid data. Test character counter on strategy field.",
            "parentId": "undefined",
            "updatedAt": "2026-02-14T16:22:09.572Z"
          }
        ],
        "updatedAt": "2026-02-14T16:22:09.572Z"
      },
      {
        "id": 5,
        "title": "Implement generate code flow with code editor",
        "description": "Implement Generate Code flow calling POST /api/v1/backtest/generate. Integrate Monaco Editor with Python syntax highlighting. Show model info, strategy summary, generation duration, detected tickers. Handle loading state and timeout (30s).",
        "details": "Create src/components/backtest/CodeEditorPanel.tsx with Monaco Editor (Python language, read-only by default, editable on user modification). Create src/hooks/useGenerateCode.ts with useMutation for POST /api/v1/backtest/generate, handle loading/success/error states, timeout after 30s. Display model info badge, strategy summary, generation time, tickers found. Disable Execute button if no generated code exists.",
        "testStrategy": "Test generate with valid/invalid strategy. Test timeout handling. Test error display. Verify code editor populates correctly.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add generation metadata to Zustand store",
            "description": "Add GenerationMetadata type to the store state interface to track model_info, strategy_summary, tickers_found, and generation_time_seconds alongside generated code. Update useBacktestStore with new state fields and setter actions.",
            "dependencies": [],
            "details": "The current Zustand store only tracks generatedCode, jobId, jobStatus, results, and uiToggles. We need to extend it to also store the metadata returned from the generate API: model_info (provider, model_id), strategy_summary, tickers_found array, and generation_time_seconds. Add setGenerationMetadata action to update these fields.",
            "status": "done",
            "testStrategy": "Verify store correctly updates all new metadata fields. Test that setGenerationMetadata properly replaces previous values. Verify reset() clears all new fields.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create useGenerateCode hook with mutation and timeout",
            "description": "Create src/hooks/useGenerateCode.ts with React Query's useMutation hook calling generateCode from the API client. Implement 30-second timeout handling using AbortController. Handle loading state via isPending, success state updating the store with code and metadata, and error state. Import and use setGeneratedCode and setGenerationMetadata from the store to update state on success.",
            "dependencies": [
              1
            ],
            "details": "Create the useGenerateCode hook that wraps generateCode API call with useMutation. Add AbortController for 30-second timeout. Handle isPending for loading, isError for errors, and onSuccess to update Zustand store with generated code and metadata. Store needs setGeneratedCode and setGenerationMetadata actions.",
            "status": "done",
            "testStrategy": "Test mutation with valid BacktestRequest succeeds and updates store. Test timeout after 30s triggers timeout error. Test network error displays correctly. Verify isLoading, isError, isSuccess states work as expected.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create CodeEditorPanel component with Monaco Editor",
            "description": "Create src/components/backtest/CodeEditorPanel.tsx using @monaco-editor/react. Configure with language: 'python', readOnly by default. Add internal state for editMode toggle - when user clicks edit button, set readOnly to false. Accept code prop and onChange callback. Include loading state with LoadingSpinner when code is being generated. Style with dark theme matching project aesthetics.",
            "dependencies": [
              2
            ],
            "details": "Use @monaco-editor/react to create CodeEditorPanel component. Configure Monaco with language: 'python', readOnly: true by default, and dark theme. Add editMode state that toggles readOnly when user clicks edit button. Accept code string prop and onChange callback for code modifications. Show LoadingSpinner from UI components when isLoading is true.",
            "status": "done",
            "testStrategy": "Test Monaco Editor renders with Python syntax highlighting. Test readOnly mode prevents editing. Test edit mode allows code modification. Test onChange callback fires when code is edited. Test loading spinner displays during generation.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create GenerationInfo display component",
            "description": "Create src/components/backtest/GenerationInfo.tsx to display metadata returned from generation: ModelInfo badge showing provider/model_id, strategy_summary text, generation_time_seconds with formatting, and tickers_found as pills/tags. Accept generation metadata as props and handle empty/null states gracefully.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create GenerationInfo component that displays ModelInfo (provider + model_id as badge), strategy_summary (text paragraph), generation_time_seconds (formatted duration), and tickers_found (array rendered as styled pill/tag components). Handle null/undefined metadata gracefully with empty state. Use existing UI components like Alert or custom styling for the badges and pills.",
            "status": "done",
            "testStrategy": "Test ModelInfo badge displays provider and model_id correctly. Test strategy_summary renders text properly. Test generation_time displays in human-readable format. Test tickers render as styled pills. Test empty/null states show appropriate placeholders.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate all components into BacktestWorkspace",
            "description": "Update BacktestWorkspace.tsx to integrate the new components: Add Generate Code button that triggers useGenerateCode mutation, pass generatedCode from store to CodeEditorPanel, add GenerationInfo component below code editor, and add Execute button that is disabled when no generated code exists in store. Wire up all callbacks and state connections properly.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Modify BacktestWorkspace to use useGenerateCode hook. Replace placeholder code section with CodeEditorPanel component passing generatedCode from store. Add GenerationInfo component to show metadata. Update Generate Code button to call mutate with form data. Add Execute button that is disabled={!generatedCode}. Handle loading state on buttons. Show error state from mutation.",
            "status": "done",
            "testStrategy": "Test Generate button triggers code generation. Test CodeEditorPanel displays generated code. Test GenerationInfo shows metadata after successful generation. Test Execute button is disabled when no code exists. Test loading state shows during generation. Test error state displays on failure.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement execute/polling flow with status display",
        "description": "Implement Execute Backtest flow calling POST /api/v1/backtest/execute with async_mode=true. Implement polling mechanism calling GET /api/v1/backtest/status/{job_id} every 2 seconds. Handle pending/running/completed/failed states.",
        "details": "Create src/hooks/useExecuteBacktest.ts with useMutation for POST /api/v1/backtest/execute. Create src/hooks/useJobPolling.ts with useQuery refetchInterval: 2000ms, stop polling on terminal states. UI States: Submitting, Pending (show job_id), Running (show elapsed), Completed, Failed (show error + logs). Create StatusBanner component. Handle network errors with retry, 404 errors, long-running job elapsed counter.",
        "testStrategy": "Test execute flow with mock API. Test polling stops on completion/failure. Test network error handling. Verify job_id displays correctly.",
        "priority": "high",
        "dependencies": [
          "3",
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create useExecuteBacktest hook with useMutation",
            "description": "Create src/hooks/useExecuteBacktest.ts with useMutation for POST /api/v1/backtest/execute. Use executeBacktest API from lib/api/client.ts. Pass async_mode=true in request. Update Zustand store with jobId and jobStatus on success. Handle loading state (isPending), error state, and success callback.",
            "dependencies": [],
            "details": "Create useExecuteBacktest hook that calls executeBacktest(payload: ExecuteBacktestRequest) from API client. Set async_mode: true in the request payload. On success, call setJobState(jobId, status) from useBacktestStore. Export mutate function, isPending, isError, error states. Use try/catch for error handling.",
            "status": "pending",
            "testStrategy": "Test execute mutation with mock API response. Verify isPending state during submission. Test error handling with mock API failure. Verify jobId and jobStatus are set in store on success.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create useJobPolling hook with useQuery",
            "description": "Create src/hooks/useJobPolling.ts with useQuery for polling GET /api/v1/backtest/status/{job_id} every 2 seconds. Stop polling on terminal states (completed, failed, cancelled, timeout). Use getJobStatus from lib/api/client.ts.",
            "dependencies": [
              1
            ],
            "details": "Create useJobPolling hook that accepts jobId. Use useQuery with refetchInterval: 2000ms. Define queryKey: ['jobStatus', jobId]. Implement queryFn: getJobStatus(jobId). Use enabled: !!jobId. Implement getJobResult for terminal states to fetch results. Return status, data, isLoading, error. Handle network errors with retry (3 attempts).",
            "status": "pending",
            "testStrategy": "Test polling stops when job reaches terminal state. Verify polling interval is 2 seconds. Test 404 error handling. Verify retry logic works correctly. Test with mock job status progression.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create StatusBanner component for job status display",
            "description": "Create src/components/backtest/StatusBanner.tsx component to display job status. Support states: Submitting, Pending (show job_id), Running (show elapsed time), Completed, Failed (show error + logs). Use Alert and Card components from UI library.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create StatusBanner component with props: status (JobStatus), jobId, error?, logs?, startTime?. Use LoadingSpinner for non-terminal states. Display job_id in Pending state. Calculate and display elapsed time in Running state (use setInterval). Show error message and logs in Failed state. Use color coding: blue=pending, yellow=running, green=completed, red=failed.",
            "status": "pending",
            "testStrategy": "Test each status display. Verify elapsed time counter works. Test error and logs display. Verify loading spinner shows correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate hooks into BacktestWorkspace",
            "description": "Update BacktestWorkspace.tsx to wire up Execute button. Import useExecuteBacktest and useJobPolling hooks. Connect StatusBanner to display job status. Handle button disabled state (disable if no generated code).",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "In BacktestWorkspace, import useExecuteBacktest and useJobPolling. Add Execute button onClick handler that calls executeMutation with generated code. Use jobId from store for useJobPolling. Display StatusBanner when jobId exists. Show results when status is completed.",
            "status": "pending",
            "testStrategy": "Test Execute button disabled state. Verify StatusBanner displays correctly. Test full execute flow with mock API. Verify polling starts after job submission.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add error handling and elapsed time counter",
            "description": "Add network error handling with retry, 404 error handling, and elapsed time counter. Implement retry logic (3 attempts with exponential backoff) for network errors. Handle 404 by showing job not found message.",
            "dependencies": [
              1,
              2
            ],
            "details": "In useJobPolling, configure retry: 3 with retryDelay: exponential backoff. Handle 404 specifically with isJobNotFound state. Add elapsed time tracking using startTime timestamp in store. Display elapsed time in HH:MM:SS format in StatusBanner.",
            "status": "pending",
            "testStrategy": "Test retry behavior with mock network failures. Test 404 handling. Verify elapsed time displays correctly for long-running jobs.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement results visualization components",
        "description": "Implement results visualization: primary metrics (total_return, cagr, max_drawdown with benchmark delta), secondary metrics (sharpe, sortino, calmar), equity curve chart with log scale toggle, drawdown chart, monthly returns heatmap, trade table.",
        "details": "Create src/components/results/MetricsCards.tsx with primary/secondary metrics. Create EquityChart.tsx with Recharts LineChart (strategy + benchmark lines, log scale toggle). Create DrawdownChart.tsx with AreaChart. Create MonthlyHeatmap.tsx with custom grid. Create TradeTable.tsx with collapsible panel, sortable columns, action/profit formatting. All handle loading/empty states.",
        "testStrategy": "Test metrics display with mock data. Test equity chart with/without benchmark. Test log scale toggle. Test heatmap color coding. Test trade table sorting.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MetricsCards component for primary/secondary metrics display",
            "description": "Create src/components/results/MetricsCards.tsx to display primary metrics (total_return, cagr, max_drawdown with benchmark delta) and secondary metrics (sharpe, sortino, calmar). Use Card component for layout, format percentages/currency values, show loading spinner when metrics are not available, display empty state with appropriate message when results are null.",
            "dependencies": [],
            "details": "Create MetricsCards component that accepts PerformanceMetrics and benchmark data as props. Display primary metrics in a prominent grid showing total return, CAGR, and max drawdown with benchmark comparison (delta). Show secondary metrics (Sharpe ratio, Sortino ratio, Calmar ratio) in a separate section. Handle loading state with LoadingSpinner, and empty state with Alert when metrics are unavailable. Use formatPercentage and formatNumber utility functions for value display.",
            "status": "done",
            "testStrategy": "Test with mock PerformanceMetrics data. Verify primary/secondary metric display. Test loading state rendering. Test empty state handling. Verify benchmark delta calculation and display.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create EquityChart component with Recharts LineChart and log scale toggle",
            "description": "Create src/components/results/EquityChart.tsx with Recharts LineChart displaying strategy and benchmark equity curves, include log scale toggle using Toggle component, handle loading and empty states appropriately.",
            "dependencies": [],
            "details": "Create EquityChart component using Recharts LineChart that accepts equity_curve data from BacktestResultResponse. Display strategy line in primary color (brand-500) and benchmark line in secondary color (slate-400). Implement log scale toggle that switches between linear and logarithmic y-axis using Recharts YAxis type='logDomain'. Handle loading state with LoadingSpinner, and empty state with Alert when equity_curve data is null or empty. Add proper tooltips showing date and value. Use existing Toggle component for log scale switch.",
            "status": "done",
            "testStrategy": "Test with mock EquityCurveData including both strategy and benchmark. Test log scale toggle functionality. Verify chart renders with single line (no benchmark). Test loading and empty states. Verify tooltip displays correct values.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create DrawdownChart component with Recharts AreaChart",
            "description": "Create src/components/results/DrawdownChart.tsx with Recharts AreaChart to visualize drawdown data over time, handle loading and empty states.",
            "dependencies": [],
            "details": "Create DrawdownChart component using Recharts AreaChart that accepts drawdown data from BacktestResultResponse. Display drawdown as negative percentage values with gradient fill. Configure XAxis for dates and YAxis for percentage values. Add tooltip showing date and drawdown percentage. Handle loading state with LoadingSpinner, and empty state with Alert when drawdown data is unavailable. Use area gradient from brand-500 to transparent for visual effect.",
            "status": "done",
            "testStrategy": "Test with mock DrawdownData. Verify area chart renders correctly with gradient. Test loading state rendering. Test empty state handling. Verify tooltip shows correct negative percentage values.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create MonthlyHeatmap component with custom grid for monthly returns",
            "description": "Create src/components/results/MonthlyHeatmap.tsx with custom grid layout to display monthly returns heatmap, implement color coding for positive/negative returns, handle loading and empty states.",
            "dependencies": [],
            "details": "Create MonthlyHeatmap component that accepts monthly_heatmap data from BacktestResultResponse. Render custom grid with years as rows and months as columns. Implement color coding: green shades for positive returns, red shades for negative returns, gray for null values. Display percentage values in each cell with proper formatting. Handle loading state with LoadingSpinner, and empty state with Alert when monthly_heatmap data is unavailable. Use CSS grid or flexbox for layout.",
            "status": "done",
            "testStrategy": "Test with mock MonthlyHeatmapData including multiple years. Verify color coding matches return values. Test handling of null values. Test loading state rendering. Test empty state handling. Verify grid layout is responsive.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create TradeTable component with sortable columns and collapsible panel",
            "description": "Create src/components/results/TradeTable.tsx with collapsible panel, sortable columns, and action/profit formatting, display trade details including entry/exit dates, ticker, action (buy/sell), profit/loss, handle loading and empty states.",
            "dependencies": [],
            "details": "Create TradeTable component that accepts trades array from BacktestResultResponse. Implement collapsible panel using existing UI patterns - show header with trade count and expand/collapse toggle. Implement sortable columns for date, ticker, action, profit. Format action as 'Buy'/'Sell' badges with color coding (green for buy, red for sell). Format profit/loss with color coding (green for profit, red for loss) and percentage values. Handle loading state with LoadingSpinner, and empty state with Alert when trades array is empty or null. Use standard HTML table with proper semantic markup.",
            "status": "done",
            "testStrategy": "Test with mock trades array. Verify sort functionality on each column. Test collapsible panel expand/collapse. Test action badge coloring. Test profit/loss formatting and coloring. Test loading state rendering. Test empty state handling.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement CSV export functionality",
        "description": "Implement CSV export for equity curve, drawdown, monthly returns, metrics, trades. Buttons disabled until results available.",
        "details": "Create src/lib/export/csv.ts with generators: generateEquityCSV, generateDrawdownCSV, generateMonthlyCSV, generateMetricsCSV, generateTradesCSV. Create src/components/results/ExportButtons.tsx with 5 download buttons, disabled until results available. Filename format: backtest_{type}_{job_id}_{date}.csv. Handle special characters, add BOM for Excel.",
        "testStrategy": "Test CSV generation with mock data. Test file download in browser. Verify CSV opens in Excel. Test disabled state.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CSV export utility library structure",
            "description": "Create src/lib/export/ directory and csv.ts file with utility functions for CSV generation including BOM handling, filename generation, and special character escaping",
            "dependencies": [],
            "details": "Create src/lib/export/csv.ts with: 1) CSV_BOM constant for Excel compatibility, 2) escapeCSVValue() function to handle special characters (commas, quotes, newlines), 3) generateFilename() function with format backtest_{type}_{job_id}_{date}.csv, 4) downloadCSV() function using Blob and URL.createObjectURL for browser download",
            "status": "pending",
            "testStrategy": "Test BOM is correctly prepended. Test special character escaping with commas, quotes, newlines. Test filename format with various job IDs and dates.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CSV generator functions for all data types",
            "description": "Implement generateEquityCSV, generateDrawdownCSV, generateMonthlyCSV, generateMetricsCSV, and generateTradesCSV functions that transform BacktestResultResponse data into CSV strings",
            "dependencies": [
              1
            ],
            "details": "Create 5 generator functions: 1) generateEquityCSV(equityCurve) - date, strategy_value columns (plus benchmark if available), 2) generateDrawdownCSV(drawdown) - date, drawdown_percent columns, 3) generateMonthlyCSV(monthlyHeatmap) - year, month, return columns, 4) generateMetricsCSV(metrics) - metric_name, value columns for all PerformanceMetrics fields, 5) generateTradesCSV(trades) - columns from trade records with dynamic field extraction. All functions accept jobId and format date as YYYYMMDD.",
            "status": "pending",
            "testStrategy": "Test each generator with mock BacktestResultResponse data. Verify CSV headers are correct. Test with null benchmark in equity data. Test with empty trades array.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create ExportButtons component",
            "description": "Create src/components/results/ExportButtons.tsx with 5 download buttons for equity, drawdown, monthly returns, metrics, and trades",
            "dependencies": [
              2
            ],
            "details": "Create ExportButtons.tsx with: 1) Props for results (BacktestResultResponse | null) and jobId (string | null), 2) 5 Button components using Button variant='secondary', 3) Disabled state when results is null or jobId is null, 4) Each button calls corresponding generator + downloadCSV on click, 5) Button labels: Export Equity, Export Drawdown, Export Monthly, Export Metrics, Export Trades",
            "status": "pending",
            "testStrategy": "Test buttons are disabled when results is null. Test buttons are disabled when jobId is null. Test each button triggers correct CSV download. Verify button click handlers are properly attached.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate ExportButtons into BacktestWorkspace results panel",
            "description": "Add ExportButtons component to the results section in BacktestWorkspace.tsx, importing from components/results and passing results and jobId from store",
            "dependencies": [
              3
            ],
            "details": "Update BacktestWorkspace.tsx: 1) Import ExportButtons from @/components/results, 2) Add ExportButtons component inside the results panel section (uiToggles.selectedTab === 'results'), 3) Pass results={results} and jobId={jobId} props, 4) Place above the placeholder Alert component",
            "status": "pending",
            "testStrategy": "Test ExportButtons renders when results panel is open. Test ExportButtons is hidden when results panel is closed. Verify results and jobId are correctly passed.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add unit tests for CSV generation and download",
            "description": "Create test files for CSV utility functions and ExportButtons component following existing test patterns in the project",
            "dependencies": [
              4
            ],
            "details": "Create tests: 1) src/lib/export/csv.test.ts for utility functions - test escapeCSVValue, generateFilename, downloadCSV (mocked), 2) src/components/results/ExportButtons.test.tsx - test disabled states, button click handlers with mocked download. Follow existing test patterns from frontend/tests/unit/",
            "status": "pending",
            "testStrategy": "Run all tests to verify CSV generation works correctly. Verify ExportButtons component renders with correct disabled states. Mock window.URL.createObjectURL for download tests.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9,
        "title": "Configure CORS and production routing",
        "description": "Configure CORS for production Next.js domain in FastAPI. Update root path redirect to new frontend. Set up production deployment topology.",
        "details": "Backend (backend/main.py): Update CORS middleware with ALLOWED_ORIGINS env var, allow specific frontend origin in production. Update root redirect from /dashboard/ to new frontend URL with feature flag. Keep /dashboard for rollback. Nginx: proxy /api/* to FastAPI, serve Next.js. Frontend: update NEXT_PUBLIC_API_BASE_URL, configure standalone output in next.config.js. docker-compose.prod.yml: Next.js + FastAPI + Nginx.",
        "testStrategy": "Test CORS with specific origin. Test root redirect. Verify /dashboard works for rollback. Test production build.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add ALLOWED_ORIGINS environment variable to backend config",
            "description": "Add ALLOWED_ORIGINS env var to Settings class in backend/core/config.py for production CORS configuration. Update main.py CORS middleware to use this setting.",
            "dependencies": [],
            "details": "Add allowed_origins: list[str] field to Settings class with default empty list. Update CORS middleware in main.py to use settings.allowed_origins in production mode instead of empty list. Allow specific frontend domain like 'https://yoyak.org'.",
            "status": "pending",
            "testStrategy": "Test CORS with specific origin via curl or browser devtools. Verify OPTIONS requests work for the configured origin.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement feature flag for root redirect with rollback support",
            "description": "Update root redirect in backend/main.py with USE_NEW_FRONTEND feature flag. Add FRONTEND_URL env var and keep /dashboard for rollback.",
            "dependencies": [
              1
            ],
            "details": "Add USE_NEW_FRONTEND (bool) and FRONTEND_URL (str) to Settings. Update root endpoint '/' to conditionally redirect to new frontend URL or /dashboard/ based on feature flag. Keep /dashboard mount for legacy dashboard rollback.",
            "status": "pending",
            "testStrategy": "Test root redirect with flag enabled/disabled. Verify /dashboard still accessible when flag is enabled.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update nginx configuration to proxy API and serve Next.js",
            "description": "Update nginx/custom.conf to add routing rules: proxy /api/* to FastAPI, serve Next.js static files, handle production domains.",
            "dependencies": [],
            "details": "Add location /api/ proxy_pass to FastAPI (backtest-api:8000). Add location / for Next.js with proper static file handling. Configure upstream backtest-api service. Add proper headers forwarding (Host, X-Real-IP, X-Forwarded-For).",
            "status": "pending",
            "testStrategy": "Test nginx config syntax with nginx -t. Verify /api/* routes to backend and / routes to Next.js.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configure frontend for production deployment",
            "description": "Update frontend environment configuration and next.config.js for production deployment. Add production NEXT_PUBLIC_API_BASE_URL.",
            "dependencies": [],
            "details": "Create .env.production with NEXT_PUBLIC_API_BASE_URL=/api/v1 (relative for proxy). Verify next.config.js standalone output is configured. Ensure proper asset prefix configuration for production domain.",
            "status": "pending",
            "testStrategy": "Run production build (npm run build). Verify standalone output created. Test API calls work through proxy.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update docker-compose.prod.yml with Next.js service",
            "description": "Add Next.js frontend service to docker-compose.prod.yml alongside FastAPI and Nginx. Configure proper networking and environment variables.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add nextjs-frontend service with Next.js standalone image or build context. Configure VIRTUAL_HOST, VIRTUAL_PORT for nginx-proxy. Add to backtest-network. Set NEXT_PUBLIC_API_BASE_URL environment variable. Configure volume for static assets if needed.",
            "status": "pending",
            "testStrategy": "Test docker-compose config with docker-compose -f docker-compose.prod.yml config. Verify all services can start without errors.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 10,
        "title": "Setup tests, CI, and deployment configuration",
        "description": "Implement unit tests, integration tests with mocked API, E2E tests for critical path. Add CI pipeline with linting, type checking, test execution.",
        "details": "Create tests/unit/: validation.test.ts, api-mappers.test.ts, csv-export.test.ts. Create tests/integration/: generate-flow.test.tsx, execute-flow.test.tsx, results-display.test.tsx. Create tests/e2e/: critical-path.test.ts with full flow (input->generate->execute->result->export). CI Pipeline: eslint, tsc --noEmit, vitest, next build. Add regression checks: compare metrics with Dash output, snapshot tests for charts.",
        "testStrategy": "Run npm run test. Verify E2E passes in CI. Check test coverage. Verify no TypeScript errors.",
        "priority": "medium",
        "dependencies": [
          "4",
          "5",
          "6",
          "7",
          "8"
        ],
        "status": "completed",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CSV export module and unit tests",
            "description": "Implement CSV export functionality and create unit tests. Create src/lib/export/csv.ts with generators: generateEquityCSV, generateDrawdownCSV, generateMonthlyCSV, generateMetricsCSV, generateTradesCSV. Create tests/unit/csv-export.test.ts with test cases for all CSV generators, special character handling, and BOM addition for Excel compatibility.",
            "dependencies": [
              8
            ],
            "details": "First implement Task 8 (CSV export) since it's a dependency. Create CSV generation functions that handle equity curve, drawdown, monthly returns, metrics, and trades data. Implement filename format: backtest_{type}_{job_id}_{date}.csv. Write comprehensive unit tests covering: valid data generation, special characters escaping, BOM handling for Excel, edge cases (empty data, missing fields).",
            "status": "completed",
            "testStrategy": "Test CSV generation with mock data. Verify file download in browser. Test disabled button state until results available.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create API mappers module and unit tests",
            "description": "Create data transformation utilities and test them. Implement src/lib/api/mappers.ts for transforming API responses to component-friendly formats. Create tests/unit/api-mappers.test.ts with test cases for mapping raw API data to UI state, handling null/undefined values, formatting dates and numbers.",
            "dependencies": [
              4,
              5,
              6
            ],
            "details": "Create mapper functions that transform: BacktestResultResponse to MetricsCards props, ExecutionResult to chart data formats, JobStatusResponse to UI status strings. Handle null safety, date formatting (ISO to locale), number formatting (percentages, currency). Write tests for edge cases: missing benchmark data, empty equity curves, partial trade data.",
            "status": "completed",
            "testStrategy": "Test mapper functions with mock API responses. Verify output matches expected component props. Test error handling for malformed data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create integration tests for generate/execute flows and results display",
            "description": "Create integration tests for critical user flows using mocked MSW handlers. Create tests/integration/generate-flow.test.tsx, execute-flow.test.tsx, results-display.test.tsx with full flow testing from form submission to result display.",
            "dependencies": [
              4,
              5,
              6,
              7
            ],
            "details": "Create tests/integration/ directory. For generate-flow: test full generate flow from ConfigForm submission through code generation, validate code editor population, verify validation errors. For execute-flow: test execute mutation, job polling behavior, status banner transitions (pending->running->completed/failed). For results-display: test MetricsCards, EquityChart, DrawdownChart, MonthlyHeatmap, TradeTable integration with mock result data. Use existing MSW handlers from tests/mocks/server.ts.",
            "status": "completed",
            "testStrategy": "Run npm run test. Verify all integration tests pass. Check that mocked API calls are made correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Setup E2E tests for critical path with Playwright",
            "description": "Install Playwright and create E2E tests for full user journey. Create tests/e2e/critical-path.test.ts that tests complete flow: input->generate->execute->result->export.",
            "dependencies": [
              4,
              5,
              6,
              7,
              8
            ],
            "details": "Install @playwright/test. Create playwright.config.ts with webServer config for dev server. Create tests/e2e/critical-path.test.ts covering: 1) Form input and validation, 2) Generate code button and code editor, 3) Execute backtest and status polling, 4) Results display and chart interactions, 5) CSV export buttons (after Task 8). Configure CI to run Playwright tests with headed/headless browsers. Handle slow API responses with increased timeouts.",
            "status": "completed",
            "testStrategy": "Run playwright test. Verify E2E passes in CI. Test across multiple browsers (chromium, firefox).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Enhance CI pipeline with frontend tests and add regression checks",
            "description": "Update .github/workflows/ci.yml to include frontend testing steps. Add regression checks with chart snapshots and metric comparisons.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update CI workflow to add frontend job: 1) Setup Node.js, 2) Install frontend dependencies with cache, 3) Run eslint on src/, 4) Run tsc --noEmit, 5) Run vitest with coverage, 6) Run next build. Add regression checks: 1) Add vitest-snapshot for chart component snapshots, 2) Create baseline metrics JSON for regression testing, 3) Compare new metrics output against baseline. Configure test coverage thresholds (e.g., 80%). Add artifact upload for test results and coverage reports.",
            "status": "completed",
            "testStrategy": "Verify CI passes all frontend steps. Check test coverage meets threshold. Verify no TypeScript errors. Confirm E2E tests run in CI environment.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement JWT authentication system for backend and frontend",
        "description": "Implement JWT authentication with access/refresh tokens, password hashing, protected routes, and secure token storage across backend (FastAPI) and frontend (Next.js/React)",
        "details": "## Backend Implementation (FastAPI)\n\n### 1. Add Dependencies\nAdd to `requirements-server.txt`:\n- `bcrypt==4.2.1` - Password hashing\n- `python-jose[cryptography]==3.3.0` - JWT handling  \n- `pydantic[email]` - Email validation\n\n### 2. Create User Model\nCreate `backend/models/user.py` with SQLAlchemy model:\n- `User` table with id, email, hashed_password, is_active, created_at, updated_at columns\n- Email should be unique and indexed\n\n### 3. Create Auth Schemas\nCreate `backend/api/v1/schemas/auth.py`:\n- `LoginRequest`: email, password\n- `LoginResponse`: access_token, refresh_token, token_type\n- `RefreshRequest`: refresh_token  \n- `RefreshResponse`: access_token, token_type\n- `UserResponse`: id, email, created_at\n- `TokenPayload`: sub (user_id), exp, type (access/refresh)\n\n### 4. Create Auth Service\nCreate `backend/services/auth_service.py`:\n- `verify_password(plain_password, hashed_password)` - Verify bcrypt password\n- `get_password_hash(password)` - Hash password with bcrypt\n- `create_access_token(data, expires_delta)` - Create JWT access token (15 min)\n- `create_refresh_token(data, expires_delta)` - Create JWT refresh token (7 days)\n- `verify_token(token)` - Verify and decode JWT\n\n### 5. Add Auth Endpoints\nCreate `backend/api/v1/endpoints/auth.py`:\n- `POST /api/v1/auth/login`: Validate credentials, return tokens\n- `POST /api/v1/auth/logout`: Invalidate refresh token (store in blocklist)\n- `POST /api/v1/auth/refresh`: Exchange refresh token for new access token\n- `GET /api/v1/auth/me`: Get current user (protected)\n\n### 6. Implement Token Authentication\nCreate `backend/api/v1/dependencies/auth.py`:\n- `get_current_user(token)` - Dependency to extract and verify access token\n- `get_current_active_user(user)` - Ensure user is active\n\n### 7. Protect Existing Endpoints\nUpdate `backend/api/v1/endpoints/backtest.py`:\n- Add `Depends(get_current_user)` to protected endpoints\n\n### 8. Add Environment Variables\nUpdate `backend/.env.example`:\n```\nSECRET_KEY=your-secret-key-here\nACCESS_TOKEN_EXPIRE_MINUTES=15\nREFRESH_TOKEN_EXPIRE_DAYS=7\n```\n\n## Frontend Implementation (Next.js/React)\n\n### 1. Create Auth Store\nCreate `frontend/src/stores/useAuthStore.ts`:\n```typescript\ninterface AuthState {\n  accessToken: string | null;\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  setAccessToken: (token: string | null) => void;\n  setUser: (user: User | null) => void;\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => Promise<void>;\n  refreshToken: () => Promise<boolean>;\n}\n```\n\n### 2. Create Auth API Client\nCreate `frontend/src/lib/api/auth.ts`:\n- `login(email, password)`: POST /api/v1/auth/login\n- `logout()`: POST /api/v1/auth/logout\n- `refreshAccessToken()`: POST /api/v1/auth/refresh\n- `getCurrentUser()`: GET /api/v1/auth/me\n\n### 3. Update API Client\nUpdate `frontend/src/lib/api/client.ts`:\n- Add request interceptor to include `Authorization: Bearer {accessToken}` header\n- Add response interceptor to handle 401:\n  - Try refresh token\n  - If refresh fails, clear tokens and redirect to login\n\n### 4. Create Login Page\nCreate `frontend/src/app/login/page.tsx`:\n- Email input with validation\n- Password input (show/hide toggle)\n- Submit button with loading state\n- Error message display\n- Redirect to home on success\n\n### 5. Create Protected Route Wrapper\nCreate `frontend/src/components/auth/ProtectedRoute.tsx`:\n- Check authentication state\n- Show loading spinner while checking\n- Redirect to /login if not authenticated\n- Render children if authenticated\n\n### 6. Update Root Layout\nUpdate `frontend/src/app/layout.tsx`:\n- Add auth state listener\n- Show user info/logout in header when authenticated\n\n### 7. Create Logout Button Component\nCreate `frontend/src/components/auth/LogoutButton.tsx`:\n- Call logout on click\n- Clear tokens and redirect to login\n\n## Security Considerations\n\n### Token Storage\n- **Access Token**: Store in React state/memory only (NOT in localStorage - XSS prevention)\n- **Refresh Token**: HttpOnly cookie with `Secure`, `SameSite=Strict`\n\n### Backend Token Validation\n- Verify token signature using SECRET_KEY\n- Check token expiration\n- Validate token type (access vs refresh)\n\n### Token Rotation\n- On refresh: Issue new access token + new refresh token\n- Invalidate old refresh token (add to blocklist or use family ID)\n\n### Password Security\n- Never store plain passwords\n- Use bcrypt with appropriate salt rounds (12)\n- Validate password strength (min 8 chars)\n\n### CORS Configuration\n- Configure `ACCESS_TOKEN_EXPOSE_HEADERS` to allow cookie propagation\n- Ensure credentials: true in CORS config",
        "testStrategy": "## Backend Tests\n1. Test user registration and password hashing with bcrypt\n2. Test login with valid/invalid credentials\n3. Test access token expiration (15 min)\n4. Test refresh token flow\n5. Test protected endpoint with valid/invalid token\n6. Test logout invalidates refresh token\n\n## Frontend Tests  \n1. Test login form validation\n2. Test successful login flow\n3. Test token storage (access in memory, refresh in cookie)\n4. Test 401 interceptor triggers refresh\n5. Test logout clears state\n6. Test protected route redirects unauthenticated users\n\n## Integration Tests\n1. Test complete login -> access protected endpoint -> logout flow\n2. Test token refresh maintains session\n3. Test expired access token auto-refreshes\n\n## Manual Verification\n1. Login with valid credentials  tokens returned\n2. Access protected endpoint with token  success  \n3. Wait for access token expiry  auto-refresh works\n4. Logout  tokens cleared, cannot access protected endpoints",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add backend dependencies and create User model",
            "description": "Add required Python packages (bcrypt==4.2.1, python-jose[cryptography]==3.3.0, pydantic[email]) to requirements-server.txt, create User SQLAlchemy model in backend/models/user.py with id, email, hashed_password, is_active, created_at, updated_at columns (email unique and indexed), and add auth-related environment variables (SECRET_KEY, ACCESS_TOKEN_EXPIRE_MINUTES=15, REFRESH_TOKEN_EXPIRE_DAYS=7) to backend/core/config.py Settings class",
            "dependencies": [],
            "details": "Create User model following existing SQLAlchemy patterns in backend/models/backtest.py. Use bcrypt for password hashing with 12 salt rounds. Add email field with unique constraint and index. Add is_active boolean default=True. Include created_at and updated_at timestamps using datetime.now(timezone.utc). Add database session setup in backend/core/container.py or create separate database.py module.",
            "status": "done",
            "testStrategy": "Test User model creation and password hashing. Verify email unique constraint works. Test User.to_dict() method returns correct fields.",
            "parentId": "undefined",
            "updatedAt": "2026-02-15T08:14:37.879Z"
          },
          {
            "id": 2,
            "title": "Create auth schemas and auth service",
            "description": "Create Pydantic auth schemas in backend/api/v1/schemas/auth.py (LoginRequest, LoginResponse, RefreshRequest, RefreshResponse, UserResponse, TokenPayload) and implement auth service in backend/services/auth_service.py with functions: verify_password, get_password_hash, create_access_token (15 min expiry), create_refresh_token (7 day expiry), verify_token",
            "dependencies": [
              1
            ],
            "details": "Create schemas following existing patterns in backend/api/v1/endpoints/backtest.py. Use pydantic BaseModel with Field for validation. AuthService should use SECRET_KEY from settings for JWT signing. Token payload should include sub (user_id), exp, type (access/refresh). Use python-jose for JWT encoding/decoding with HS256 algorithm.",
            "status": "done",
            "testStrategy": "Test password hashing with bcrypt. Test token creation and verification. Test token expiration handling. Test invalid token rejection.",
            "parentId": "undefined",
            "updatedAt": "2026-02-15T08:15:52.006Z"
          },
          {
            "id": 3,
            "title": "Implement auth endpoints and token authentication",
            "description": "Create auth endpoints in backend/api/v1/endpoints/auth.py: POST /api/v1/auth/login, POST /api/v1/auth/logout, POST /api/v1/auth/refresh, GET /api/v1/auth/me. Create dependency in backend/api/v1/dependencies/auth.py for get_current_user and get_current_active_user. Update existing backtest.py endpoints to require authentication.",
            "dependencies": [
              2
            ],
            "details": "Follow router pattern from backend/api/v1/endpoints/backtest.py. Login endpoint verifies credentials and returns access_token + refresh_token. Refresh endpoint exchanges refresh token for new access token. Logout adds refresh token to blocklist (can use in-memory set for MVP). /me endpoint returns current user info. Dependency get_current_user extracts Bearer token from Authorization header, verifies JWT, returns user. Update backtest.py add Depends(get_current_user) to protected endpoints.",
            "status": "done",
            "testStrategy": "Test login with valid/invalid credentials. Test access token expires after 15 minutes. Test refresh token flow. Test protected endpoint with valid/invalid token. Test logout invalidates refresh token.",
            "parentId": "undefined",
            "updatedAt": "2026-02-15T08:18:13.270Z"
          },
          {
            "id": 4,
            "title": "Create frontend auth store and update API client",
            "description": "Create frontend auth Zustand store in frontend/src/stores/useAuthStore.ts with state: accessToken, user, isAuthenticated, isLoading, and methods: setAccessToken, setUser, login, logout, refreshToken. Create auth API client in frontend/src/lib/api/auth.ts with login, logout, refreshAccessToken, getCurrentUser functions.",
            "dependencies": [],
            "details": "Follow Zustand pattern from frontend/src/stores/useBacktestStore.ts. Auth store should store accessToken in memory only (NOT localStorage for XSS prevention). User should include id, email, created_at fields. Login method calls /api/v1/auth/login and stores tokens. Refresh method calls /api/v1/auth/refresh. Logout clears state and calls /api/v1/auth/logout. Create auth.ts API client with axios calls to auth endpoints. Update client.ts to add request interceptor for Authorization header and response interceptor for 401 handling (try refresh, then redirect to login).",
            "status": "done",
            "testStrategy": "Test auth store state updates on login/logout. Test token refresh on 401 response. Test API client sends correct headers. Test logout clears all auth state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-15T08:19:47.168Z"
          },
          {
            "id": 5,
            "title": "Create login page and protected route components",
            "description": "Create login page in frontend/src/app/login/page.tsx with email/password inputs, validation, loading state, error display, and redirect on success. Create ProtectedRoute component in frontend/src/components/auth/ProtectedRoute.tsx that checks authentication and redirects to /login. Create LogoutButton component in frontend/src/components/auth/LogoutButton.tsx. Update frontend/src/app/layout.tsx to include auth header with user info and logout button when authenticated.",
            "dependencies": [
              4
            ],
            "details": "Follow UI component patterns from frontend/src/components/ui/ (Button, Input). Login page should use useAuthStore for login/logout. ProtectedRoute should show loading spinner while checking auth state. Use useEffect to check auth on mount. Redirect to /login if not authenticated, render children if authenticated. LogoutButton calls logout() and redirects to login. Layout update adds Header component modification - show email and logout button when isAuthenticated=true.",
            "status": "done",
            "testStrategy": "Test login form validation. Test login success redirects to home. Test login failure shows error. Test ProtectedRoute redirects unauthenticated users. Test logout clears state and redirects. Test header shows user info when logged in.",
            "parentId": "undefined",
            "updatedAt": "2026-02-15T08:22:02.883Z"
          }
        ],
        "updatedAt": "2026-02-15T08:22:02.883Z"
      },
      {
        "id": 12,
        "title": "Configure Supabase Custom SMTP (Resend) and email confirmation for production",
        "description": "Before production launch, configure Supabase Auth email delivery with a custom SMTP provider (Resend) and enforce email verification flow.",
        "details": "Set up a verified sending domain in Resend, configure SPF/DKIM (and DMARC if available), then connect Supabase Authentication SMTP settings using provider SMTP credentials. Ensure Supabase Auth URLs (site URL and redirect URLs) match production domain. Enable email confirmation for sign-up, test duplicate registration and unconfirmed-login behaviors, and document operational playbook for resend/recovery.",
        "testStrategy": "1) Register new account and verify confirmation email is delivered to inbox (not spam). 2) Confirm user via email link and verify login succeeds. 3) Verify unconfirmed user cannot log in when confirmation is required. 4) Verify duplicate email returns conflict response and UI message. 5) Verify password reset and magic-link/confirmation links resolve to production URLs.",
        "status": "pending",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Provision Resend domain and DNS records",
            "description": "Add production domain in Resend and apply required DNS records (SPF, DKIM, optional DMARC) until verification is green.",
            "dependencies": [],
            "details": "Use production sending subdomain (for example, mail.yourdomain.com or yourdomain.com). Add records at DNS provider and wait for propagation. Keep screenshots or exported DNS records for operations documentation.",
            "status": "pending",
            "testStrategy": "Confirm domain status is verified in Resend and test send succeeds.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Connect Supabase SMTP settings to Resend",
            "description": "Configure Supabase Authentication SMTP host, port, username, password, sender name, and sender email with Resend credentials.",
            "dependencies": [
              1
            ],
            "details": "Update Supabase Authentication > Settings > SMTP. Verify sender identity matches verified domain and store SMTP credentials securely in ops vault.",
            "status": "pending",
            "testStrategy": "Trigger confirmation email from Supabase dashboard and confirm delivery.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Enable and validate production email confirmation flow",
            "description": "Enable Confirm Email in Supabase Auth for production and validate register/confirm/login path end-to-end.",
            "dependencies": [
              2
            ],
            "details": "Set site URL and redirect URLs to production frontend routes. Verify backend and frontend show clear messages for unconfirmed accounts and successful confirmation.",
            "status": "pending",
            "testStrategy": "Run register -> confirm email -> login flow with a real mailbox and verify behavior.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Document runbook and fallback policy",
            "description": "Document SMTP setup, troubleshooting steps, and temporary fallback policy for incidents.",
            "dependencies": [
              3
            ],
            "details": "Include common failure cases: DNS misconfiguration, blocked sender, spam placement, and provider outage. Define temporary policy for controlled signup if email delivery degrades.",
            "status": "pending",
            "testStrategy": "Review runbook with deployment checklist and verify all required fields are covered.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-15T12:06:23.000Z"
      },
      {
        "id": 13,
        "title": "Add OAuth2 login/logout integration",
        "description": "Extend the existing authentication system to support OAuth2-based login and logout flows across backend and frontend.",
        "details": "Backend: add OAuth2 provider configuration, callback endpoint, token exchange, and account-linking strategy with existing users. Frontend: add OAuth login button and callback handling, store issued app JWT/session securely, and implement logout that revokes/invalidates session consistently. Infra: add required env vars, redirect URI validation, and CORS/cookie settings for local + production. Testing: add integration tests for success/failure callback, existing-user linking, and logout behavior.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Add OAuth2 configuration and environment variables",
            "description": "Add OAuth provider configuration and environment variables for backend and frontend including OAuth redirect URIs, allowed providers, and CORS settings for OAuth callbacks",
            "dependencies": [],
            "details": "Backend: Add OAUTH_PROVIDERS_ENABLED (comma-separated list like 'google,github'), OAUTH_REDIRECT_URL_BASE (production redirect base), to backend/core/config.py. Update .env.example with OAuth vars. Frontend: Add NEXT_PUBLIC_OAUTH_PROVIDERS to frontend .env.local.example. Update CORS settings to allow OAuth provider domains.",
            "status": "pending",
            "testStrategy": "Verify env var loading in backend config. Test CORS configuration accepts OAuth callback redirects."
          },
          {
            "id": 2,
            "title": "Implement OAuth callback endpoint in backend",
            "description": "Create OAuth sign-in initiation and callback endpoints in backend auth service and API to handle OAuth provider redirects and token exchange via Supabase",
            "dependencies": [
              1
            ],
            "details": "Backend: Add OAuthSignInResponse schema to backend/api/v1/schemas/auth.py with provider, url fields. Add /auth/oauth/signin endpoint in backend/api/v1/endpoints/auth.py that returns Supabase OAuth URL. Add /auth/oauth/callback endpoint that handles code exchange and returns session tokens. Update AuthService in backend/services/auth_service.py to support OAuth sign-in methods. Ensure proper error handling for OAuth failures.",
            "status": "pending",
            "testStrategy": "Test /auth/oauth/signin returns valid OAuth URL for each provider. Test /auth/oauth/callback successfully exchanges code for session tokens. Test error handling for invalid codes."
          },
          {
            "id": 3,
            "title": "Add OAuth login button in frontend login page",
            "description": "Add OAuth provider login buttons to the frontend login page with proper styling and loading states",
            "dependencies": [
              2
            ],
            "details": "Frontend: Update frontend/src/app/login/page.tsx to add OAuth provider buttons (Google, GitHub) below the email/password form. Create OAuthButton component in frontend/src/components/auth/OAuthButton.tsx. Add provider icons and consistent styling with existing login form. Handle loading state during OAuth redirect.",
            "status": "pending",
            "testStrategy": "Verify OAuth buttons render correctly with provider icons. Test clicking OAuth button initiates OAuth flow (redirects to provider). Verify responsive design works on mobile."
          },
          {
            "id": 4,
            "title": "Extend frontend auth store to handle OAuth tokens",
            "description": "Extend the Zustand auth store to handle OAuth session tokens, callback processing, and proper logout that invalidates OAuth sessions",
            "dependencies": [
              2,
              3
            ],
            "details": "Frontend: Update frontend/src/stores/useAuthStore.ts to add oauthLogin(provider) method that calls /auth/oauth/signin and redirects to provider. Add handleOAuthCallback() method to process callback URL and exchange code for tokens. Update logout() to properly revoke OAuth session via Supabase. Store OAuth provider info in user state.",
            "status": "pending",
            "testStrategy": "Test oauthLogin initiates correct redirect. Test handleOAuthCallback successfully exchanges code for tokens. Test logout invalidates session and clears all tokens."
          },
          {
            "id": 5,
            "title": "Add integration tests for OAuth flow",
            "description": "Create integration tests for OAuth authentication flow including success/failure callbacks, account linking with existing users, and logout behavior",
            "dependencies": [
              4
            ],
            "details": "Backend tests: Add tests/api/v1/test_auth_oauth.py with tests for OAuth signin endpoint, callback success with valid code, callback failure with invalid code. Test account linking when OAuth email matches existing user. Frontend tests: Add tests for OAuthButton component rendering, OAuth flow initiation. Test logout behavior.",
            "status": "pending",
            "testStrategy": "Run pytest for backend OAuth tests. Run Playwright or Vitest for frontend OAuth component tests. Verify all tests pass including error handling scenarios."
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-15T12:06:23.000Z",
      "taskCount": 12,
      "completedCount": 3,
      "tags": [
        "master"
      ],
      "created": "2026-02-15T12:10:48.726Z",
      "description": "Tasks for master context",
      "updated": "2026-02-15T12:10:48.729Z"
    }
  }
}